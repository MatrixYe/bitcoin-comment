---
title: 挖矿流程源码
date: 2025-12-29 03:02:54
updated: 2025-12-29 03:03:36
tags: []
---

## 一、挖矿涉及的核心数据结构

### 1. CBlock - 区块结构

[main.h:628-665](file:///Users/yepeng/Codes/bitcoin-comment/bitcoin-0.3.19/main.h#L628-L665)

```cpp
class CBlock {
public:
  // 区块头信息 - 挖矿的核心计算对象
  int nVersion;               // 区块版本号
  uint256 hashPrevBlock;      // 前一区块哈希（区块链链接）
  uint256 hashMerkleRoot;     // 交易梅克尔树根（挖矿目标）
  unsigned int nTime;         // 时间戳（随时间更新）
  unsigned int nBits;         // 难度目标（压缩格式）
  unsigned int nNonce;        // 随机数（挖矿要改变的值）

  // 交易列表 - 区块包含的所有交易
  vector<CTransaction> vtx;

  // 梅克尔树 - 用于快速验证交易完整性
  mutable vector<uint256> vMerkleTree;
};
```

### 2. CTransaction - 交易结构

[main.h:65-200](file:///Users/yepeng/Codes/bitcoin-comment/bitcoin-0.3.19/main.h#L65-L200)

```cpp
class CTransaction {
public:
  // 交易输入列表
  vector<CTxIn> vin;
  // 交易输出列表
  vector<CTxOut> vout;
  // 交易锁定时间
  unsigned int nLockTime;
};
```

### 3. CBlockIndex - 区块链索引

[main.h:860-877](file:///Users/yepeng/Codes/bitcoin-comment/bitcoin-0.3.19/main.h#L860-L877)

```cpp
class CBlockIndex {
public:
  const uint256 *phashBlock;  // 指向区块哈希
  CBlockIndex *pprev;         // 指向前一区块（后向链接）
  CBlockIndex *pnext;         // 指向后一区块（前向链接）
  unsigned int nFile;         // 区块存储文件编号
  unsigned int nBlockPos;     // 区块在文件中的位置
  int nHeight;                // 区块高度
};
```

### 4. CTxIn/CTxOut - 交易输入输出

[main.h:215-280](file:///Users/yepeng/Codes/bitcoin-comment/bitcoin-0.3.19/main.h#L215-L280)

```cpp
// 交易输入：引用前一交易的输出
class CTxIn {
public:
  COutPoint prevout;          // 引用前一交易的输出点
  CScript scriptSig;          // 解锁脚本（提供签名）
};

// 交易输出：包含一定数量的比特币
class CTxOut {
public:
  int64 nValue;               // 输出金额（单位：聪）
  CScript scriptPubKey;       // 锁定脚本（指定收款人）
};
```

## 二、挖矿代码逻辑

### 1. 挖矿入口：ThreadBitcoinMiner

[main.cpp:2611-2630](file:///Users/yepeng/Codes/bitcoin-comment/bitcoin-0.3.19/main.cpp#L2611-L2630)

```cpp
// 挖矿线程入口函数
// 参数 parg: 线程参数（未使用）
void ThreadBitcoinMiner(void *parg) {
  try {
    vnThreadsRunning[3]++;  // 增加运行中的挖矿线程计数
    BitcoinMiner();          // 调用主挖矿函数
    vnThreadsRunning[3]--;  // 减少线程计数
  } catch (std::exception &e) {
    vnThreadsRunning[3]--;
    PrintException(&e, "ThreadBitcoinMiner()");  // 打印异常信息
  } catch (…) {
    vnThreadsRunning[3]--;
    PrintException(NULL, "ThreadBitcoinMiner()");
  }
  
  // 更新UI状态和哈希速率统计
  UIThreadCall(boost::bind(CalledSetStatusBar, "", 0));
  nHPSTimerStart = 0;
  if (vnThreadsRunning[3] == 0)
    dHashesPerSec = 0;  // 无挖矿线程时清除哈希速率
  
  printf("ThreadBitcoinMiner exiting, %d threads remaining\n",
         vnThreadsRunning[3]);
}
```

### 2. 主挖矿循环：BitcoinMiner

[main.cpp:3023-3155](file:///Users/yepeng/Codes/bitcoin-comment/bitcoin-0.3.19/main.cpp#L3023-L3155)

```cpp
// 主挖矿函数
// 流程：创建区块 → 准备哈希缓冲区 → 循环扫描随机数 → 验证并提交
void BitcoinMiner() {
  printf("BitcoinMiner started\n");
  SetThreadPriority(THREAD_PRIORITY_LOWEST);  // 设置低优先级，避免影响其他操作
  
  // 检测CPU是否支持128位SSE2（用于加速SHA256计算）
  bool f4WaySSE2 = Detect128BitSSE2();
  if (mapArgs.count("-4way"))
    f4WaySSE2 = GetBoolArg(mapArgs["-4way"]);

  // 每个挖矿线程有独立的密钥和额外随机数
  CReserveKey reservekey;       // 预留密钥（用于创币交易）
  unsigned int nExtraNonce = 0; // 额外随机数（扩展搜索空间）
  int64 nPrevTime = 0;          // 上次时间（用于检测时间变化）

  // 主循环：持续挖矿直到被停止
  while (fGenerateBitcoins) {
    if (AffinityBugWorkaround(ThreadBitcoinMiner))
      return;
    if (fShutdown)
      return;
    
    // 等待网络连接同步完成
    while (vNodes.empty() || IsInitialBlockDownload()) {
      Sleep(1000);
      if (fShutdown)
        return;
      if (!fGenerateBitcoins)
        return;
    }

    //
    // 第一步：创建新区块
    //
    unsigned int nTransactionsUpdatedLast = nTransactionsUpdated;
    CBlockIndex *pindexPrev = pindexBest;  // 获取最新区块

    // 创建包含交易的新区块
    auto_ptr<CBlock> pblock(CreateNewBlock(reservekey));
    if (!pblock.get())
      return;
    
    // 更新额外随机数（改变创币交易的哈希，从而改变梅克尔根）
    IncrementExtraNonce(pblock.get(), pindexPrev, nExtraNonce, nPrevTime);

    printf("Running BitcoinMiner with %d transactions in block\n",
           pblock->vtx.size());

    //
    // 第二步：准备哈希计算缓冲区
    //
    char pmidstatebuf[32 + 16];
    char *pmidstate = alignup<16>(pmidstatebuf);  // 中间状态缓冲区
    char pdatabuf[128 + 16];
    char *pdata = alignup<16>(pdatabuf);          // 数据缓冲区
    char phash1buf[64 + 16];
    char *phash1 = alignup<16>(phash1buf);        // 哈希结果缓冲区

    // 格式化哈希缓冲区
    FormatHashBuffers(pblock.get(), pmidstate, pdata, phash1);

    // 获取区块时间戳和随机数字段的引用（用于快速更新）
    unsigned int &nBlockTime = *(unsigned int *)(pdata + 64 + 4);
    unsigned int &nBlockNonce = *(unsigned int *)(pdata + 64 + 12);

    //
    // 第三步：扫描随机数（工作量证明计算）
    //
    int64 nStart = GetTime();  // 记录开始时间
    uint256 hashTarget = CBigNum().SetCompact(pblock->nBits).getuint256();  // 难度目标
    uint256 hashbuf[2];
    uint256 &hash = *alignup<16>(hashbuf);  // 哈希结果
    
    loop {
      unsigned int nHashesDone = 0;   // 本轮完成的哈希数量
      unsigned int nNonceFound;       // 找到的随机数
      
#ifdef FOURWAYSSE2
      if (f4WaySSE2)
        // 使用4-way SSE2加速（如果可用）
        nNonceFound = ScanHash_4WaySSE2(pmidstate, pdata + 64, phash1,
                                        (char *)&hash, nHashesDone);
      else
#endif
        // 使用Crypto++库进行SHA256计算
        nNonceFound = ScanHash_CryptoPP(pmidstate, pdata + 64, phash1,
                                        (char *)&hash, nHashesDone);

      // 检查是否找到有效随机数
      if (nNonceFound != -1) {
        // 字节序转换（比特币使用大端序）
        for (int i = 0; i < sizeof(hash) / 4; i++)
          ((unsigned int *)&hash)[i] = ByteReverse(((unsigned int *)&hash)[i]);

        // 核心验证：哈希值必须小于等于目标值
        if (hash <= hashTarget) {
          // 找到有效工作量证明！
          pblock->nNonce = ByteReverse(nNonceFound);
          assert(hash == pblock->GetHash());

          SetThreadPriority(THREAD_PRIORITY_NORMAL);  // 提高优先级处理
          CheckWork(pblock.get(), reservekey);         // 验证并提交区块
          SetThreadPriority(THREAD_PRIORITY_LOWEST);  // 恢复低优先级
          break;
        }
      }

      // 统计哈希速率（每4秒更新一次UI）
      static int64 nHashCounter;
      if (nHPSTimerStart == 0) {
        nHPSTimerStart = GetTimeMillis();
        nHashCounter = 0;
      } else
        nHashCounter += nHashesDone;
      
      if (GetTimeMillis() - nHPSTimerStart > 4000) {
        static CCriticalSection cs;
        CRITICAL_BLOCK(cs) {
          if (GetTimeMillis() - nHPSTimerStart > 4000) {
            dHashesPerSec = 1000.0 * nHashCounter / (GetTimeMillis() - nHPSTimerStart);
            nHPSTimerStart = GetTimeMillis();
            nHashCounter = 0;
            string strStatus = strprintf("    %f khash/s", dHashesPerSec / 1000.0);
            UIThreadCall(boost::bind(CalledSetStatusBar, strStatus, 0));
            // 每30分钟打印一次日志
            static int64 nLogTime;
            if (GetTime() - nLogTime > 30 * 60) {
              nLogTime = GetTime();
              printf("%s ", DateTimeStrFormat("%x %H:%M", GetTime()).c_str());
              printf("hashmeter %3d CPUs %6.0f khash/s\n", vnThreadsRunning[3],
                     dHashesPerSec / 1000.0);
            }
          }
        }
      }

      // 检查是否需要退出或重建区块
      if (fShutdown)
        return;
      if (!fGenerateBitcoins)
        return;
      if (fLimitProcessors && vnThreadsRunning[3] > nLimitProcessors)
        return;
      if (vNodes.empty())
        break;  // 断开网络，停止挖矿
      if (nBlockNonce >= 0xffff0000)
        break;  // 随机数溢出，需要更新时间戳
      if (nTransactionsUpdated != nTransactionsUpdatedLast &&
          GetTime() - nStart > 60)
        break;  // 交易池变化超过60秒，重建区块
      if (pindexPrev != pindexBest)
        break;  // 区块链分叉，重建区块

      // 每几秒更新一次时间戳（影响区块头）
      pblock->nTime = max(pindexPrev->GetMedianTimePast() + 1, GetAdjustedTime());
      nBlockTime = ByteReverse(pblock->nTime);
    }
  }
}
```

### 3. 创建新区块：CreateNewBlock

[main.cpp:2778-2930](file:///Users/yepeng/Codes/bitcoin-comment/bitcoin-0.3.19/main.cpp#L2778-L2930)

```cpp
// 创建新的待挖矿区块
// 流程：创建创币交易 → 收集内存池交易 → 计算手续费 → 设置区块奖励
CBlock *CreateNewBlock(CReserveKey &reservekey) {
  CBlockIndex *pindexPrev = pindexBest;  // 获取最新区块高度

  // 创建新区块对象
  auto_ptr<CBlock> pblock(new CBlock());
  if (!pblock.get())
    return NULL;

  // 第一步：创建创币交易（Coinbase Transaction）
  // 创币交易是区块中的第一笔交易，生成新比特币作为挖矿奖励
  CTransaction txNew;
  txNew.vin.resize(1);
  txNew.vin[0].prevout.SetNull();  // 创币交易没有输入
  txNew.vout.resize(1);
  // 输出锁定脚本：只有拥有对应私钥的人才能花费
  txNew.vout[0].scriptPubKey << reservekey.GetReservedKey() << OP_CHECKSIG;

  // 将创币交易添加到区块（作为第一笔交易）
  pblock->vtx.push_back(txNew);

  // 第二步：从内存池收集交易到区块
  int64 nFees = 0;  // 累计交易手续费
  CRITICAL_BLOCK(cs_main)
  CRITICAL_BLOCK(cs_mapTransactions) {
    CTxDB txdb("r");

    // 按优先级处理交易
    list<COrphan> vOrphan;  // 孤儿交易列表（依赖未确认交易）
    map<uint256, vector<COrphan *>> mapDependers;
    multimap<double, CTransaction *> mapPriority;  // 优先级队列
    
    // 遍历内存池中的所有交易
    for (map<uint256, CTransaction>::iterator mi = mapTransactions.begin();
         mi != mapTransactions.end(); ++mi) {
      CTransaction &tx = (*mi).second;
      if (tx.IsCoinBase() || !tx.IsFinal())  // 跳过创币交易和未final的交易
        continue;

      // 处理依赖关系
      COrphan *porphan = NULL;
      double dPriority = 0;
      foreach (const CTxIn &txin, tx.vin) {
        // 读取前序交易
        CTransaction txPrev;
        CTxIndex txindex;
        if (!txPrev.ReadFromDisk(txdb, txin.prevout, txindex)) {
          // 前序交易未确认，作为孤儿交易等待
          if (!porphan) {
            vOrphan.push_back(COrphan(&tx));
            porphan = &vOrphan.back();
          }
          mapDependers[txin.prevout.hash].push_back(porphan);
          porphan->setDependsOn.insert(txin.prevout.hash);
          continue;
        }
        int64 nValueIn = txPrev.vout[txin.prevout.n].nValue;

        // 读取区块头计算确认数
        int nConf = 0;
        CBlock block;
        if (block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false)) {
          map<uint256, CBlockIndex *>::iterator it = mapBlockIndex.find(block.GetHash());
          if (it != mapBlockIndex.end()) {
            CBlockIndex *pindex = (*it).second;
            if (pindex->IsInMainChain())
              nConf = 1 + nBestHeight - pindex->nHeight;
          }
        }

        // 优先级 = 币龄 * 金额 / 交易大小
        dPriority += (double)nValueIn * nConf;

        if (fDebug && GetBoolArg("-printpriority"))
          printf("priority     nValueIn=%-12I64d nConf=%-5d dPriority=%-20.1f\n",
                 nValueIn, nConf, dPriority);
      }

      // 计算优先级（币龄/交易大小）
      dPriority /= ::GetSerializeSize(tx, SER_NETWORK);

      if (porphan)
        porphan->dPriority = dPriority;
      else
        mapPriority.insert(make_pair(-dPriority, &(*mi).second));  // 负值实现最大堆

      if (fDebug && GetBoolArg("-printpriority")) {
        printf("priority %-20.1f %s\n%s", dPriority,
               tx.GetHash().ToString().substr(0, 10).c_str(),
               tx.ToString().c_str());
        if (porphan) porphan->print();
        printf("\n");
      }
    }

    // 将交易收集到区块中
    map<uint256, CTxIndex> mapTestPool;
    uint64 nBlockSize = 1000;  // 区块基础大小
    int nBlockSigOps = 100;    // 签名操作基础数量
    
    // 按优先级从高到低处理交易
    while (!mapPriority.empty()) {
      // 取出最高优先级交易
      double dPriority = -(*mapPriority.begin()).first;
      CTransaction &tx = *(*mapPriority.begin()).second;
      mapPriority.erase(mapPriority.begin());

      // 检查区块大小限制
      unsigned int nTxSize = ::GetSerializeSize(tx, SER_NETWORK);
      if (nBlockSize + nTxSize >= MAX_BLOCK_SIZE_GEN)  // 1MB限制
        continue;
      int nTxSigOps = tx.GetSigOpCount();
      if (nBlockSigOps + nTxSigOps >= MAX_BLOCK_SIGOPS)  // 签名操作限制
        continue;

      // 计算交易手续费
      bool fAllowFree = (nBlockSize + nTxSize < 4000 || dPriority > COIN * 144 / 250);
      int64 nMinFee = tx.GetMinFee(nBlockSize, fAllowFree);

      // 验证交易输入（连接UTXO）
      map<uint256, CTxIndex> mapTestPoolTmp(mapTestPool);
      if (!tx.ConnectInputs(txdb, mapTestPoolTmp, CDiskTxPos(1, 1, 1),
                            pindexPrev, nFees, false, true, nMinFee))
        continue;  // 验证失败，跳过此交易
      
      swap(mapTestPool, mapTestPoolTmp);

      // 交易有效，添加到区块
      pblock->vtx.push_back(tx);
      nBlockSize += nTxSize;
      nBlockSigOps += nTxSigOps;

      // 将依赖此交易的孤儿交易加入队列
      uint256 hash = tx.GetHash();
      if (mapDependers.count(hash)) {
        foreach (COrphan *porphan, mapDependers[hash]) {
          if (!porphan->setDependsOn.empty()) {
            porphan->setDependsOn.erase(hash);
            if (porphan->setDependsOn.empty())
              mapPriority.insert(make_pair(-porphan->dPriority, porphan->ptx));
          }
        }
      }
    }
  }
  
  // 第三步：设置创币交易输出金额
  // 金额 = 出块奖励 + 所有交易手续费
  pblock->vtx[0].vout[0].nValue = GetBlockValue(pindexPrev->nHeight + 1, nFees);

  // 第四步：填充区块头
  pblock->hashPrevBlock = pindexPrev->GetBlockHash();       // 设置前一区块哈希
  pblock->hashMerkleRoot = pblock->BuildMerkleTree();       // 构建梅克尔树
  pblock->nTime = max(pindexPrev->GetMedianTimePast() + 1, GetAdjustedTime());  // 时间戳
  pblock->nBits = GetNextWorkRequired(pindexPrev);          // 难度目标
  pblock->nNonce = 0;                                       // 随机数从0开始

  return pblock.release();
}
```

### 4. 提交区块：CheckWork

[main.cpp:2987-3030](file:///Users/yepeng/Codes/bitcoin-comment/bitcoin-0.3.19/main.cpp#L2987-L3030)

```cpp
// 验证工作量证明并提交区块
// 流程：双重验证 → 保留密钥 → 广播区块
bool CheckWork(CBlock *pblock, CReserveKey &reservekey) {
  uint256 hash = pblock->GetHash();  // 获取区块哈希
  uint256 hashTarget = CBigNum().SetCompact(pblock->nBits).getuint256();  // 难度目标

  // 再次验证工作量证明
  if (hash > hashTarget)
    return false;

  // 打印成功信息
  printf("BitcoinMiner:\n");
  printf("proof-of-work found  \n  hash: %s  \ntarget: %s\n",
         hash.GetHex().c_str(), hashTarget.GetHex().c_str());
  pblock->print();
  printf("%s ", DateTimeStrFormat("%x %H:%M", GetTime()).c_str());
  printf("generated %s\n", FormatMoney(pblock->vtx[0].vout[0].nValue).c_str());

  // 关键验证：确保父区块还是最佳链
  CRITICAL_BLOCK(cs_main) {
    if (pblock->hashPrevBlock != hashBestChain)
      return error("BitcoinMiner : generated block is stale");

    // 销毁预留密钥（创币交易输出已生效）
    reservekey.KeepKey();

    // 统计区块请求次数
    CRITICAL_BLOCK(cs_mapRequestCount)
    mapRequestCount[pblock->GetHash()] = 0;

    // 像接收其他节点区块一样处理此区块
    if (!ProcessBlock(NULL, pblock))
      return error("BitcoinMiner : ProcessBlock, block not accepted");
  }

  Sleep(2000);  // 等待2秒再继续挖矿
  return true;
}
```

### 5. 接收区块：ProcessBlock

[main.cpp:1427-1470](file:///Users/yepeng/Codes/bitcoin-comment/bitcoin-0.3.19/main.cpp#L1427-L1470)

```cpp
// 处理从网络接收到的区块
// 流程：去重验证 → 前序检查 → 存储到磁盘 → 递归处理孤儿区块
bool ProcessBlock(CNode *pfrom, CBlock *pblock) {
  // 检查是否已有该区块
  uint256 hash = pblock->GetHash();
  if (mapBlockIndex.count(hash))
    return error("ProcessBlock() : already have block %d %s",
                 mapBlockIndex[hash]->nHeight,
                 hash.ToString().substr(0, 20).c_str());
  if (mapOrphanBlocks.count(hash))
    return error("ProcessBlock() : already have block (orphan) %s",
                 hash.ToString().substr(0, 20).c_str());

  // 基本验证
  if (!pblock->CheckBlock())
    return error("ProcessBlock() : CheckBlock FAILED");

  // 检查是否有前序区块
  if (!mapBlockIndex.count(pblock->hashPrevBlock)) {
    printf("ProcessBlock: ORPHAN BLOCK, prev=%s\n",
           pblock->hashPrevBlock.ToString().substr(0, 20).c_str());
    // 作为孤儿区块保存
    CBlock *pblock2 = new CBlock(*pblock);
    mapOrphanBlocks.insert(make_pair(hash, pblock2));
    mapOrphanBlocksByPrev.insert(make_pair(pblock2->hashPrevBlock, pblock2));

    // 请求缺失的前序区块
    if (pfrom)
      pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(pblock2));
    return true;
  }

  // 存储到磁盘并添加到区块链
  if (!pblock->AcceptBlock())
    return error("ProcessBlock() : AcceptBlock FAILED");

  // 递归处理依赖此区块的孤儿区块
  vector<uint256> vWorkQueue;
  vWorkQueue.push_back(hash);
  for (int i = 0; i < vWorkQueue.size(); i++) {
    uint256 hashPrev = vWorkQueue[i];
    for (multimap<uint256, CBlock *>::iterator mi =
             mapOrphanBlocksByPrev.lower_bound(hashPrev);
         mi != mapOrphanBlocksByPrev.upper_bound(hashPrev); ++mi) {
      CBlock *pblockOrphan = (*mi).second;
      if (pblockOrphan->AcceptBlock())
        vWorkQueue.push_back(pblockOrphan->GetHash());
      mapOrphanBlocks.erase(pblockOrphan->GetHash());
      delete pblockOrphan;
    }
    mapOrphanBlocksByPrev.erase(hashPrev);
  }

  printf("ProcessBlock: ACCEPTED\n");
  return true;
}
```

## 三、挖矿完整流程图

```
┌─────────────────────────────────────────────────────────────────┐
│                        挖矿主循环                                │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  1. 检查条件                                                    │
│     - 网络连接正常                                              │
│     - 区块同步完成                                              │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  2. 创建新区块 (CreateNewBlock)                                 │
│     ├─ 创建创币交易（生成新BTC作为奖励）                         │
│     ├─ 从内存池收集交易（按优先级排序）                          │
│     ├─ 验证交易输入（连接UTXO）                                  │
│     └─ 设置区块头：hashPrevBlock, hashMerkleRoot, nBits         │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  3. 准备哈希缓冲区 (FormatHashBuffers)                          │
│     ├─ 格式化区块头数据                                          │
│     └─ 初始化SHA256状态                                         │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  4. 扫描随机数 (ScanHash)                                       │
│     ├─ 循环改变nNonce（0 ~ 2^32）                               │
│     ├─ 对区块头进行SHA256双重哈希                                │
│     ├─ 比较结果与难度目标                                        │
│     └─ 条件满足 → 找到工作量证明                                 │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  5. 提交区块 (CheckWork → ProcessBlock)                         │
│     ├─ 验证工作量证明                                            │
│     ├─ 将创币输出密钥标记为已使用                                │
│     ├─ 验证区块有效性                                            │
│     ├─ 存储到磁盘                                               │
│     ├─ 更新区块链索引                                            │
│     └─ 广播给其他节点                                            │
└─────────────────────────────────────────────────────────────────┘
```

## 四、核心概念

| 概念 | 说明 |
|------|------|
| **工作量证明** | 通过 SHA256 哈希计算，找到小于难度目标的随机数 |
| **难度目标** | 根据全网算力自动调整，控制出块时间约 10 分钟 |
| **梅克尔根** | 所有交易哈希的根，用于快速验证交易完整性 |
| **创币交易** | 区块第一笔交易，生成新 BTC 作为矿工奖励 |
| **交易手续费** | 用户为加速交易确认而支付的小额 BTC |
| **确认数** | 区块在区块链中的深度，越多越安全 |
